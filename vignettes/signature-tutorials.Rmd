---
title: "SigRepo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SigRepo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(
  message = TRUE,
  warning = TRUE,
  error = TRUE,
  collapse = TRUE,
  comment = "#>"
)

# Load R packages
# For data cleaning, extraction and manipulation
library(tidyverse)

# For loading and installing packages
library(devtools)

# Load SigRepo package
devtools::load_all()

# Load OmicSignature package
library("OmicSignature")

```

# Introduction

The `SigRepo` package includes a suite of functions for easily storing and managing biological signatures and its constituents. Currently, `Sigrepo` is capable of storing, searching, and retrieving signatures and its signature collections from a MySQL Database of choice. See <a href="">here</a> for how set-up the MySQL database with the appropriate schema.

In order to interact with a suite of functions in `SigRepo` package, the input data must represent an R6 object for the representation of signatures and signature collections, and they can be created using our proprietary package, <a href="https://github.com/montilab/OmicSignature">OmicSignature</a>. 

For more information click the links below.

- [Overview of the object structure](https://montilab.github.io/OmicSignature/articles/ObjectStructure.html)
- [Create an OmicSignature (OmS)](https://montilab.github.io/OmicSignature/articles/CreateOmS.html)
- [Create an OmicSignatureCollection (OmSC)](https://montilab.github.io/OmicSignature/articles/CreateOmSC.html)

For demonstrations, we will walk through the steps of how to use `SigRepo` package to store, retrieve, and interact with a list of signatures stored in our MySQL SigRepo Database. 

# Installation

- Using `devtools` package

```
# Load devtools package
library(devtools)

# Install SigRepo
devtools::install_github(repo = 'montilab/SigRepo')

# Install OmicSignature
devtools::install_github(repo = 'montilab/OmicSignature')
```

# Load packages 

```
# Load tidyverse package
library(tidyverse)

# Load SigRepo package
library(SigRepo)

# Load OmicSignature package
library(OmicSignature)
```

# Connect to SigRepo Database

We adopt a MySQL Database structure for efficiently storing, searching, and retrieving the biological signatures and its constituents. To access the signatures stored in our database, you <a href="">MUST register here</a> to create an account or <a href="">contact our admin</a> to be added.

There are three types of user accounts:<br>
- `admin` has <b>READ</b> and <b>WRITE</b> access to all signatures in the database.<br>
- `editor` has <b>READ</b> and <b>WRITE</b> access to ONLY their own uploaded signatures in the database.<br>
- `viewer` has <b>ONLY READ</b> access to see a list of signatures that are publicly available in the database but <b>DO NOT HAVE WRITE</b> access to the database.<br>

Once you have a valid account, to connect to our SigRepo database, one can use the `newConnHandler()` function to create a handler which contains user credentials to establish connection to our database.

```{r}
# Create a connection handler
conn_handler <- SigRepo::newConnHandler(
  dbname = Sys.getenv("DBNAME"), 
  host = Sys.getenv("HOST"), 
  port = as.integer(Sys.getenv("PORT")), 
  user = Sys.getenv("USER"), 
  password = Sys.getenv("PASSWORD")
)
# closing the connection
on.exit(DBI::dbDisconnect(conn), add = TRUE)
```

# Load Signatures

Here, we provide two signature objects that comes with the package for demonstrations:

1. omic_signature_AGS_OmS (**LLFS_Aging_Gene_2023**)
2. omic_signature_MDA_CYP (**CYP181 knockdown in breast cancer cell line**)

```{r}
# Getting the signature path
signature_path <- base::system.file("inst/data/signatures", package = "SigRepo")

# Read in the signature object
omic_signature_AGS_OmS <- base::readRDS(base::file.path(signature_path, "omic_signature_AGS_OmS.RDS"))
omic_signature_MDA_CYP <- base::readRDS(base::file.path(signature_path, "omic_signature_MDA_CYP.RDS"))
```

# Upload a signature

The `addSignature()` function allows users to upload a signature to the database. 

__IMPORTANT NOTE:__ 

- The user **MUST HAVE** an `editor` or `admin` account to use this function. 
- A signature **MUST BE** an R6 object obtained from **OmicSignature::OmicSignature()**

## **Example 1**: Create an omic signature using **OmicSignature** package and upload to the database 

```{r Example 1}
# Create signature metadata
metadata <- base::list(
  # required attributes:
  signature_name = "Myc_reduce_mice_liver_24m",
  organism = "Mus Musculus",
  direction_type = "bi-directional",
  assay_type = "transcriptomics",
  phenotype = "Myc_reduce",
  
  # optional and recommended:
  covariates = "none",
  description = "mice MYC reduced expression",
  platform = "GPL6246", # use GEO platform ID
  sample_type = "liver", # use BRENDA ontology
  
  # optional cut-off attributes.
  # specifying them can facilitate the extraction of signatures.
  logfc_cutoff = NULL,
  p_value_cutoff = NULL,
  adj_p_cutoff = 0.05,
  score_cutoff = 5,
  
  # other optional built-in attributes:
  keywords = c("Myc", "KO", "longevity"),
  cutoff_description = NULL,
  author = NULL,
  PMID = 25619689,
  year = 2015,
  
  # example of customized attributes:
  others = list("animal_strain" = "C57BL/6")
)

# Create difexp object
difexp <- base::readRDS(file.path(system.file("extdata", package = "OmicSignature"), "difmatrix_Myc_mice_liver_24m.rds")) %>% dplyr::rename(feature_name = ensembl)
colnames(difexp) <- OmicSignature::replaceDifexpCol(colnames(difexp))

# Create signature object
signature <- difexp %>%
  dplyr::filter(abs(score) > metadata$score_cutoff & adj_p < metadata$adj_p_cutoff) %>%
  dplyr::select(probe_id, feature_name, score) %>%
  dplyr::mutate(direction = ifelse(score > 0, "+", "-"))

# Create signature object 
omic_signature <- OmicSignature::OmicSignature$new(
  metadata = metadata,
  signature = signature,
  difexp = difexp
)

# Add signature to database
SigRepo::addSignature(
  conn_handler = conn_handler,        # A handler contains user credentials to establish connection to a remote database
  omic_signature = omic_signature,    # An R6 object obtained from OmicSignature::OmicSignature()
  visibility = FALSE,                 # Whether to make signature public or private. Default is FALSE.
  return_signature_id = FALSE,        # Whether to return the uploaded signature id. Default is FALSE.
  verbose = TRUE                      # Whether to print diagnostic messages. Default is TRUE.
)
```

## **Example 2**: Upload `omic_signature_AGS_OmS` signature

```{r Example 2}
SigRepo::addSignature(
  conn_handler = conn_handler, 
  omic_signature = omic_signature_AGS_OmS
)
```

## **Example 3**: Upload `omic_signature_MDA_CYP` signature

```{r Example 3}
SigRepo::addSignature(
  conn_handler = conn_handler, 
  omic_signature = omic_signature_MDA_CYP,
  return_missing_features = TRUE                # Whether to return a list of missing features during upload. Default is FALSE.
)
```

# Search for a list of signatures

The `searchSignature()` function allows users to search for all or a specific set of signatures that are available in the database. 

## Example 1: Search for all signatures 

```{r}
signature_tbl <- SigRepo::searchSignature(conn_handler = conn_handler)

if(nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl, 
    row.names = FALSE
  )
}
```

## Example 2: Search for a specific signature, e.g., **signature_name = "LLFS_Aging_Gene_2023"**.

```{r} 
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "LLFS_Aging_Gene_2023"
)

if(nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl, 
    row.names = FALSE
  )
}
```

# Retrieve a list of omic signatures

The `getSignature()` function allows users to retrieve a list of omic signature objects that they are **PUBLICLY** available in the database. 

__IMPORTANT NOTE:__ 

- Users **MUST HAVE** an `editor` or `admin` account to use this function. 
- Users can **ONLY RETRIEVE** a list of signatures that are publicly available in the database including their own uploaded signatures. 
- If a signature is `PRIVATE` and belongs to other user in the database, users will need to be given an `editor` permission from its owner in order to access, retrieve, and edit their signatures.

## Example 1: Retrieve all signatures that are publicly available or owned by the user in the database

```{r}
signature_list <- SigRepo::getSignature(conn_handler = conn_handler)
```

## Example 2: Retrieve a specific signature that is publicly available or owned by the user in the database, e.g., **signature_name = "LLFS_Aging_Gene_2023"**

```{r}
LLFS_oms <- SigRepo::getSignature(
  conn_handler = conn_handler, 
  signature_id = "LLFS_Aging_Gene_2023"
)
```

# Delete a signature

The `deleteSignature()` function allows users to delete a signature from the database. 

__IMPORTANT NOTE:__ 

- Users **MUST HAVE** an `editor` or `admin` account to use this function. 
- Users can **ONLY DELETE** their own uploaded signatures or were given an `editor` permission from its owner to access, retrieve, and edit their signatures.
- Users can **ONLY DELETE** a signature one at a time.

**For example:** You want to remove **signature_name = "LLFS_Aging_Gene_2023"** from the database.

```{r}
# 1. Let's search for signature_name = "LLFS_Aging_Gene_2023" in the database
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "LLFS_Aging_Gene_2023"
)

# 2. If the signature exists, remove it from the database
if(nrow(signature_tbl) > 0){
  SigRepo::deleteSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id
  )
}
```

# Update a signature 

The `updateSignature()` function allows users to update a specific signature in the SigRepo database. 

__IMPORTANT NOTE:__ 

- Users **MUST HAVE** an `editor` or `admin` account to use this function. 
- Users can **ONLY UPDATE** their own uploaded signatures or were given an `editor` permission from its owner to access, retrieve, and edit their signatures.
- Users can **ONLY UPDATE** a signature one at a time.

**For example:** If the `platform` information in the previous uploaded signature, **"Myc_reduce_mice_liver_24m"**, is incorrect, and you wish to update the `platform` information with the correct value, e.g., **platform = "GPLXXXXX"**. You can use the `updateSignature()` function as follows:

```{r}
# 1. Revise the metadata object with new platform = GPLXXXXX
metadata_revised <- base::list(
  # required attributes:
  signature_name = "Myc_reduce_mice_liver_24m",
  organism = "Mus Musculus",
  direction_type = "bi-directional",
  assay_type = "transcriptomics",
  phenotype = "Myc_reduce",
  
  # optional and recommended:
  covariates = "none",
  description = "mice MYC reduced expression",
  platform = "GPLXXXXX", # use GEO platform ID
  sample_type = "liver", # use BRENDA ontology
  
  # optional cut-off attributes.
  # specifying them can facilitate the extraction of signatures.
  logfc_cutoff = NULL,
  p_value_cutoff = NULL,
  adj_p_cutoff = 0.05,
  score_cutoff = 5,
  
  # other optional built-in attributes:
  keywords = c("Myc", "KO", "longevity"),
  cutoff_description = NULL,
  author = NULL,
  PMID = 25619689,
  year = 2015,
  
  # example of customized attributes:
  others = list("animal_strain" = "C57BL/6")
)

# 2. Create difexp object
difexp <- readRDS(file.path(system.file("extdata", package = "OmicSignature"), "difmatrix_Myc_mice_liver_24m.rds")) %>% dplyr::rename(feature_name = ensembl)
colnames(difexp) <- OmicSignature::replaceDifexpCol(colnames(difexp))

# 3. Create signature object
signature <- difexp %>%
  dplyr::filter(abs(score) > metadata_revised$score_cutoff & adj_p < metadata_revised$adj_p_cutoff) %>%
  dplyr::select(probe_id, feature_name, score) %>%
  dplyr::mutate(direction = ifelse(score > 0, "+", "-"))

# 4. Create the updated OmicSignature object
updated_omic_signature <- OmicSignature::OmicSignature$new(
  signature = signature,
  metadata = metadata_revised,
  difexp = difexp
)
```

```{r}
# Now, let's search for Myc_reduce_mice_liver_24m in the database
# in which we would like to revise the value of platform to GPLXXXXX
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = metadata_revised$signature_name
)

# Update the signature with the revised omic_signature object
if(nrow(signature_tbl) > 0){
  SigRepo::updateSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id, 
    omic_signature = updated_omic_signature
  )
}
```

Finally, let's look up **signature_name = "Myc_reduce_mice_liver_24m"** and see if the value of `platform` has been changed.

```{r}
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "Myc_reduce_mice_liver_24m"
)

if(nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl,
    row.names = FALSE
  )
}
```

```{r, include=FALSE}
# 1. Let's search for signature_name = "Myc_reduce_mice_liver_24m" in the database
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "Myc_reduce_mice_liver_24m"
)

# 2. If the signature exists, remove it from the database
if(nrow(signature_tbl) > 0){
  SigRepo::deleteSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id
  )
}
```

