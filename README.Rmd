---
output: rmarkdown::github_document
---

```{r, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

# Setting up knitting options
knitr::opts_chunk$set(
  fig.path = "./man/figures/", 
  message = TRUE,
  warning = TRUE,
  error = TRUE,
  collapse = TRUE,
  comment = "#>"
)

# Load R packages
# For data cleaning, extraction and manipulation
library(tidyverse)

# For loading and installing packages
library(devtools)

# Load SigRepo package
devtools::load_all()

# Load OmicSignature package
library(OmicSignature)

```

<br>

# <img src="man/figures/logo.png" align="left" width="190" /> SigRepo: An R package for storing and processing omic signatures

The `SigRepo` package includes a suite of functions for easily storing and managing biological signatures and its constituents. Currently, `Sigrepo` is capable of storing, searching, and retrieving signatures and its signature collections from a MySQL database of choice. Interest in setting-up your own `SigRepo` database? See <a href="">here</a> on how to initiate a MySQL database with the appropriate schema.

In order to interact with a suite of functions in `SigRepo` package, the input data must represent an R6 object for the representation of signatures and signature collections, and they can be created using our proprietary package, <a href="https://github.com/montilab/OmicSignature">OmicSignature</a>. 

Click on each link below for more information: 

- [Overview of the object structure](https://montilab.github.io/OmicSignature/articles/ObjectStructure.html)
- [Create an OmicSignature (OmS)](https://montilab.github.io/OmicSignature/articles/CreateOmS.html)
- [Create an OmicSignatureCollection (OmSC)](https://montilab.github.io/OmicSignature/articles/CreateOmSC.html)

For demonstrations, we will walk through the steps of how to use `SigRepo` package to store, retrieve, and interact with a list of signatures stored in our MySQL SigRepo Database. 

# Installation

- Using `devtools` package

```
# Load devtools package
library(devtools)

# Install SigRepo
devtools::install_github(repo = 'montilab/SigRepo')

# Install OmicSignature
devtools::install_github(repo = 'montilab/OmicSignature')

# Load tidyverse package
library(tidyverse)

# Load SigRepo package
library(SigRepo)

# Load OmicSignature package
library(OmicSignature)
```

# Connect to SigRepo Database

We adopt a MySQL database structure for efficiently storing, searching, and retrieving the biological signatures and its constituents. To access the signatures stored in our database, <a href="https://sigrepo.org/">VISIT OUR WEBSITE</a> to create an account or <a href="mailto:sigrepo@bu.edu">CONTACT US</a> to be added.

There are three types of user accounts:<br>
- `admin` has <b>READ</b> and <b>WRITE</b> access to all signatures in the database.<br>
- `editor` has <b>READ</b> and <b>WRITE</b> access to ONLY their own uploaded signatures in the database.<br>
- `viewer` has <b>ONLY READ</b> access to see a list of signatures that are publicly available in the database but <b>DO NOT HAVE WRITE</b> access to the database.<br>

Once you have a valid account, to connect to our SigRepo database, one can use the `newConnHandler()` function to create a handler which contains user credentials to establish connection to our database. 

```{r, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
conn_handler <- SigRepo::newConnHandler(
  dbname = Sys.getenv("DBNAME"), 
  host = Sys.getenv("HOST"), 
  port = as.integer(Sys.getenv("PORT")), 
  user = Sys.getenv("USER"), 
  password = Sys.getenv("PASSWORD")
)
```

```
# Create a connection handler
conn_handler <- SigRepo::newConnHandler(
  dbname = "sigrepo", 
  host = "sigrepo.org", 
  port = 3306, 
  user = <your_username>, 
  password = <your_password>
)
``` 

# Load Signatures

Here, we provide two signature objects that comes with the package for demonstrations:

1. LLFS_Aging_Gene_2023 
2. Myc_reduce_mice_liver_24m

```{r, warning=FALSE, echo=FALSE, message=FALSE}
# Read in the signature object
LLFS_Aging_Gene_2023 <- base::readRDS(base::file.path(base::system.file("inst/extdata", package = "SigRepo"), "LLFS_Aging_Gene_2023.rds")) 
Myc_reduce_mice_liver_24m <- base::readRDS(base::file.path(base::system.file("inst/extdata", package = "SigRepo"), "Myc_reduce_mice_liver_24m.rds")) 
```

# Upload a signature

The `addSignature()` function allows users to upload a signature to the database. 

__IMPORTANT NOTE:__ 

- User **MUST HAVE** an `editor` or `admin` account to use this function. 
- A signature **MUST BE** an R6 object obtained from **OmicSignature::OmicSignature()**

## **Example 1**: Create an omic signature using **OmicSignature** package and upload to the database 

```{r Example 1}
# Create an OmicSignature metadata
metadata <- OmicSignature::createMetadata(
  # required attributes:
  signature_name = "Myc_reduce_mice_liver_24m_readme",
  organism = "Mus musculus",
  direction_type = "bi-directional",
  assay_type = "transcriptomics",
  phenotype = "Myc_reduce",

  # optional and recommended:
  covariates = "none",
  description = "mice Myc haploinsufficient (Myc(+/-))",
  platform = "transcriptomics by array",
  sample_type = "liver", # use BRENDA ontology

  # optional cut-off attributes.
  # specifying them can facilitate the extraction of signatures.
  logfc_cutoff = NULL,
  p_value_cutoff = NULL,
  adj_p_cutoff = 0.05,
  score_cutoff = 5,

  # other optional built-in attributes:
  keywords = c("Myc", "KO", "longevity"),
  cutoff_description = NULL,
  author = NULL,
  PMID = 25619689,
  year = 2015,

  # example of customized attributes:
  others = list("animal_strain" = "C57BL/6")
)

# Create difexp object
difexp <- base::readRDS(base::file.path(base::system.file("extdata", package = "OmicSignature"), "difmatrix_Myc_mice_liver_24m.rds")) 
base::colnames(difexp) <- OmicSignature::replaceDifexpCol(base::colnames(difexp))

# Rename ensembl with feature name and add group label to difexp
difexp <- difexp |>  
  dplyr::rename(feature_name = ensembl) |> 
  dplyr::mutate(group_label = base::as.factor(base::ifelse(.data$score > 0, "MYC Reduce", "WT")))

# Create signature object
signature <- difexp |>
  dplyr::filter(base::abs(.data$score) > metadata$score_cutoff & .data$adj_p < metadata$adj_p_cutoff) |>
  dplyr::select(c("probe_id", "feature_name", "score")) |>
  dplyr::mutate(group_label = base::as.factor(base::ifelse(.data$score > 0, "MYC Reduce", "WT")))

# Create signature object 
omic_signature <- OmicSignature::OmicSignature$new(
  metadata = metadata,
  signature = signature,
  difexp = difexp
)

# Add signature to database
SigRepo::addSignature(
  conn_handler = conn_handler,        # A handler contains user credentials to establish connection to a remote database
  omic_signature = omic_signature,    # An R6 object obtained from OmicSignature::OmicSignature()
  visibility = FALSE,                 # Whether to make signature public or private. Default is FALSE.
  return_signature_id = FALSE,        # Whether to return the uploaded signature id. Default is FALSE.
  verbose = TRUE                      # Whether to print diagnostic messages. Default is TRUE.
)
```

## **Example 2**: Upload `LLFS_Aging_Gene_2023` signature

```{r Example 2}
SigRepo::addSignature(
  conn_handler = conn_handler, 
  omic_signature = LLFS_Aging_Gene_2023
)
```

## **Example 3**: Upload `Myc_reduce_mice_liver_24m` signature

```{r Example 3}
missing_features <- SigRepo::addSignature(
  conn_handler = conn_handler, 
  omic_signature = Myc_reduce_mice_liver_24m,
  return_missing_features = TRUE       # Whether to return a list of missing features during upload.
)
```

# Search for a list of signatures

The `searchSignature()` function allows users to search for all or a specific set of signatures that are available in the database. 

## Example 1: Search for all signatures 

```{r}
signature_tbl <- SigRepo::searchSignature(conn_handler = conn_handler)

if(nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl, 
    row.names = FALSE
  )
}
```

## Example 2: Search for a specific signature, e.g., **signature_name = "LLFS_Aging_Gene_2023"**

```{r} 
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "LLFS_Aging_Gene_2023"
)

if(nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl, 
    row.names = FALSE
  )
}
```

# Retrieve a list of omic signatures

The `getSignature()` function allows users to retrieve a list of omic signature objects that they are **PUBLICLY** available in the database. 

__IMPORTANT NOTE:__ 

- Users can **ONLY RETRIEVE** a list of signatures that are publicly available in the database including their own uploaded signatures. 
- If a signature is `PRIVATE` and belongs to other user in the database, users will need to be given an `editor` permission from its owner in order to access, retrieve, and edit their signatures.

## Example 1: Retrieve all signatures that are publicly available or owned by the user in the database

```{r}
signature_list <- SigRepo::getSignature(conn_handler = conn_handler)
```

## Example 2: Retrieve a specific signature that is publicly available or owned by the user in the database, e.g., **signature_name = "LLFS_Aging_Gene_2023"**

```{r}
LLFS_oms <- SigRepo::getSignature(
  conn_handler = conn_handler, 
  signature_name = "LLFS_Aging_Gene_2023"
)
```

# Delete a signature

The `deleteSignature()` function allows users to delete a signature from the database. 

__IMPORTANT NOTE:__ 

- Users **MUST HAVE** an `editor` or `admin` account to use this function. 
- Users can **ONLY DELETE** their own uploaded signatures or were given an `editor` permission from its owner to access, retrieve, and edit their signatures.
- Users can **ONLY DELETE** a signature one at a time.

**For example:** You want to remove **signature_name = "LLFS_Aging_Gene_2023"** from the database.

```{r}
# Let's search for signature_name = "LLFS_Aging_Gene_2023" in the database
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "LLFS_Aging_Gene_2023"
)

# If the signature exists, remove it from the database
if(nrow(signature_tbl) > 0){
  SigRepo::deleteSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id  
  )
}
```

# Update a signature 

The `updateSignature()` function allows users to update a specific signature in the SigRepo database. 

__IMPORTANT NOTE:__ 

- Users **MUST HAVE** an `editor` or `admin` account to use this function. 
- Users can **ONLY UPDATE** their own uploaded signatures or were given an `editor` permission from its owner to access, retrieve, and edit their signatures.
- Users can **ONLY UPDATE** a signature one at a time.

**For example:** If the `platform` information in the previous uploaded signature, **"Myc_reduce_mice_liver_24m_readme"**, is incorrect, and you wish to update the `platform` information with the correct value, e.g., **platform = "transcriptomics by single-cell RNA-seq"**. You can use the `updateSignature()` function as follows:

```{r}
# 1. Revise the metadata object with new platform = transcriptomics by single-cell RNA-seq
metadata_revised <- OmicSignature::createMetadata(
  # required attributes:
  signature_name = "Myc_reduce_mice_liver_24m_readme",
  organism = "Mus musculus",
  direction_type = "bi-directional",
  assay_type = "transcriptomics",
  phenotype = "Myc_reduce",

  # optional and recommended:
  covariates = "none",
  description = "mice Myc haploinsufficient (Myc(+/-))",
  platform = "transcriptomics by single-cell RNA-seq",
  sample_type = "liver", # use BRENDA ontology

  # optional cut-off attributes.
  # specifying them can facilitate the extraction of signatures.
  logfc_cutoff = NULL,
  p_value_cutoff = NULL,
  adj_p_cutoff = 0.05,
  score_cutoff = 5,

  # other optional built-in attributes:
  keywords = c("Myc", "KO", "longevity"),
  cutoff_description = NULL,
  author = NULL,
  PMID = 25619689,
  year = 2015,

  # example of customized attributes:
  others = list("animal_strain" = "C57BL/6")
)

# Create difexp object
difexp <- base::readRDS(base::file.path(base::system.file("extdata", package = "OmicSignature"), "difmatrix_Myc_mice_liver_24m.rds")) 
base::colnames(difexp) <- OmicSignature::replaceDifexpCol(base::colnames(difexp))

# Rename ensembl with feature name and add group label to difexp
difexp <- difexp |>  
  dplyr::rename(feature_name = ensembl) |> 
  dplyr::mutate(group_label = base::as.factor(base::ifelse(.data$score > 0, "MYC Reduce", "WT")))

# Create signature object
signature <- difexp |>
  dplyr::filter(base::abs(.data$score) > metadata$score_cutoff & .data$adj_p < metadata$adj_p_cutoff) |>
  dplyr::select(c("probe_id", "feature_name", "score")) |>
  dplyr::mutate(group_label = base::as.factor(base::ifelse(.data$score > 0, "MYC Reduce", "WT")))

# Create signature object 
updated_omic_signature <- OmicSignature::OmicSignature$new(
  metadata = metadata_revised,
  signature = signature,
  difexp = difexp
)
```

```{r}
# Now, let's search for Myc_reduce_mice_liver_24m_readme in the database
# in which we would like to revise the value of platform to 'transcriptomics by single-cell RNA-seq'
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = metadata_revised$signature_name
)

# If signature exists, update the signature with the revised omic_signature object
if(base::nrow(signature_tbl) > 0){
  SigRepo::updateSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id, 
    omic_signature = updated_omic_signature
  )
}
```

Let's look up **signature_name = "Myc_reduce_mice_liver_24m_readme"** and see if the value of `platform` has been changed.

```{r}
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "Myc_reduce_mice_liver_24m_readme"
)

if(base::nrow(signature_tbl) > 0){
  knitr::kable(
    signature_tbl,
    row.names = FALSE
  )
}
```

Finally, remove **signature_name = "Myc_reduce_mice_liver_24m_readme"** from the database

```{r}
# Let's search for signature_name = "Myc_reduce_mice_liver_24m_readme" in the database
signature_tbl <- SigRepo::searchSignature(
  conn_handler = conn_handler, 
  signature_name = "Myc_reduce_mice_liver_24m_readme"
)

# If the signature exists, remove it from the database
if(nrow(signature_tbl) > 0){
  SigRepo::deleteSignature(
    conn_handler = conn_handler, 
    signature_id = signature_tbl$signature_id
  )
}

```

# Additional Guides

- [Upload a signature collection to the SigRepo database](https://montilab.github.io/SigRepo/articles/collection-tutorials.html)
